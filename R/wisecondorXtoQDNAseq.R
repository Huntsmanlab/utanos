###########################
### Functions
###########################
# BuildWxQdnaObject

###

# Parameters:
# input_path - Path to the wisecondorX output. Expects a directory.

#' Build a QDNAseq object from the WisecondorX output files
#'
#' @description
#'
#' In order to do 1-to-1 comparisons between QDNAseq and WisecondorX outputs it is useful to have outputs in the same format.
#' This function creates a QDNAseq object out of the WisecondorX output files and returns it.
#'
#' @param input_path (string) The path to the output files generated by WisecondorX. A directory.
#' @param genome_used (string) The reference genome used for alignment. (default: hg19)
#' @param bin_size (integer) The bin size used during copy number calling in base pairs. (default: 30000)
#' @param Xincluded (logical) Whether or not the X chromosome was included in this analysis. (default: FALSE)
#' @returns A QDNAseq object.
#'
#' @export
BuildWxQdnaObject <- function (input_path, genome_used = 'hg19',
                                  bin_size = 30000, Xincluded = FALSE) {

  # Read in files
  bin_files <- list.files(input_path, pattern = '*_bins.bed', full.names = TRUE)
  samples <- list.files(input_path, pattern = '*_bins.bed')
  samples <- sub('_bins.bed', '', samples)
  seg_files <- list.files(input_path, pattern = '*_segments.bed', full.names = TRUE)
  stats_files <- list.files(input_path, pattern = '*_statistics.txt', full.names = TRUE)
  cns <- plyr::ldply(seq_along(bin_files), function(x) {
    df <- data.table::fread(bin_files[[x]], sep = '\t',
                            col.names = c('chromosome', 'start', 'end',
                                          'id', 'ratio', 'zscore'),
                            nThread = 4)
    df <- df[,c(1,2,3,5)]
    df$sample_id <- samples[x]
    colnames(df) = c('chromosome', 'start', 'end', 'state', 'sample_id')
    df})
  cns$state[is.nan(cns$state)] <- NA                                            # NaNs to NAs
  cns$state <- exp(cns$state)                                                   # Exponeniate
  segs <- lapply(seg_files, function(x) {
    df <- data.table::fread(x, sep = '\t',
                            col.names = c('chromosome', 'start', 'end',
                                          'segVal', 'zscore'))
    df <- df[,c(1,2,3,4)]
    df})
  names(segs) <- samples
  segs <- segs %>%
    purrr::map(~dplyr::mutate_at(.x, ggplot2::vars("segVal"), function(x) {exp(x)}))
  stats <- plyr::ldply(seq_along(stats_files), function(x) {
    extras <- readLines(stats_files[[x]])
    read_count <- as.integer(sub("Number of reads: ", "",
                                 extras[which(grepl("Number of reads: ", extras))]))
    df <- data.frame(name = samples[x],
                     total_reads = read_count,
                     stringsAsFactors=FALSE)
    df})
  rownames(stats) <- samples

  # Begin constructing the copy-number object
  cns_wide <- tidyr::spread(cns, sample_id, state)
  chroms <- GetBinnedChromosomes(genome_used, Xincluded, bin_size)
  cns_wide$chromosome <- factor(cns_wide$chromosome, levels = chroms$chrom)
  cns_wide <- cns_wide %>% dplyr::arrange(chromosome)
  cns_wide[,1:3] <- cns_wide %>% dplyr::select(chromosome, start, end) %>%
    dplyr::group_by(chromosome) %>%
    dplyr::mutate(end = dplyr::if_else(end == max(end),
                                       chroms$size[chroms$chrom == dplyr::first(chromosome)],
                                       end))

  dim_names <- paste0(cns_wide$chromosome, ':', cns_wide$start, '-', cns_wide$end)       # create bin dimnames
  copynumbers <- matrix(NA_real_, nrow=nrow(cns_wide), ncol=length(bin_files),
                        dimnames=list(dim_names, samples))
  copynumbers[,1:length(bin_files)] <- as.matrix(cns_wide[,4:(length(bin_files)+3)])

  # Start building the segment object
  segs_long <- SegmentsToCopyNumber(segs, bin_size = bin_size,
                                    genome = genome_used,
                                    Xincluded = TRUE)
  segs_wide <- tidyr::spread(segs_long, sample_id, segmented)
  segs_wide$chromosome <- factor(segs_wide$chromosome, levels = chroms$chrom)
  segs_wide <- segs_wide %>% dplyr::arrange(chromosome)
  segments <- matrix(NA_real_, nrow=nrow(segs_wide), ncol=length(seg_files),
                     dimnames=list(dim_names, samples))
  segments[,1:length(seg_files)] <- as.matrix(segs_wide[,4:(length(seg_files)+3)])

  # Create the bins
  bins <- matrix(NA_integer_, nrow=nrow(cns_wide), ncol=4,
                 dimnames=list(dim_names, c('chromosome', 'start', 'end', 'use')))
  bins[,1:3] <- as.matrix(cns_wide[,1:3])
  bins[,4] <- (complete.cases(segments) & complete.cases(copynumbers))
  bins <- Biobase::AnnotatedDataFrame(as.data.frame(bins))
  bins@data$chromosome <- factor(bins@data$chromosome,
                                 levels = c(as.character(c(1:22)),'X'))
  bins@data$start <- as.integer(bins@data$start)
  bins@data$end <- as.integer(bins@data$end)
  bins@data$use <- as.logical(bins@data$use)

  # Assemble QDNAseq object
  wx_qdnaobj <- new('QDNAseqCopyNumbers', bins=bins,
                    copynumber=copynumbers, phenodata=stats)
  Biobase::assayDataElement(wx_qdnaobj, "segmented") <- segments
  colnames(wx_qdnaobj@phenoData@data) <- c("name", "total.reads")               # Change to total.reads
  expected.variance <- rep(NA_real_, length(samples))
  for (i in length(samples)) {                                                  # Calculate expected variance
    expected.variance[i] <- (sum(QDNAseq:::binsToUse(wx_qdnaobj[,i])) / wx_qdnaobj[,i]$total.reads)
  }
  wx_qdnaobj@phenoData@data$expected.variance <- expected.variance
  metadata <-  matrix(NA_integer_, nrow= 3, ncol= 1,
                      dimnames=list(c('name', 'total.reads', 'expected.variance')))
  colnames(metadata) <- "labelDescription"
  wx_qdnaobj@phenoData@varMetadata <- as.data.frame(metadata)
  return(wx_qdnaobj)
}
