# Converts result of DLP (segments.csv.gz) with bin and segment copy number into a QDNAseq object

### Functions
###########################
# DlpToQDNAseq

#' Build a QDNAseq object from the DLP output files
#'
#' @description
#' In order to do 1-to-1 comparisons between QDNAseq and DLP outputs, it is useful to have outputs in the same format.
#' This function creates a QDNAseq object from the DLP output files and returns it.
#'
#' @param input_path (string) The path to the output files generated by DLP. A directory.
#' @param genome_used (string) The reference genome used for alignment. (default: hg19)
#' @param bin_size (integer) The bin size used during copy number calling in base pairs. (default: 500000)
#' @param Xincluded (logical) Whether or not the X chromosome was included in this analysis. (default: FALSE)
#' @returns A QDNAseq object.
#' @importClassesFrom QDNAseq QDNAseqCopyNumbers
#' @export
###########################
DlpToQDNAseq <- function(input_path, bin_size = 500000, genome = 'hg19', Xincluded = FALSE) {
  # Construct the file pattern
  file_pattern <- file.path(input_path, "hmmcopy", "*_segments.csv.gz")

  # List files matching the pattern
  segment_files <- list.files(path = dirname(file_pattern),
                              pattern = basename(file_pattern),
                              full.names = TRUE)

  # Filter for files that strictly end with "_segments.csv.gz"
  segment_files <- segment_files[grepl("_segments\\.csv\\.gz$", segment_files)]

  # Check how many files were found
  if (length(segment_files) == 0) {
    stop("No segment files found matching the pattern.")
  } else if (length(segment_files) > 1) {
    stop("Expected exactly one segment file, but found: ", length(segment_files))
  }

  # Assign the single segment file path to a variable
  segment_file <- segment_files[1]  # This will be the path of the found file

  # Read the segment file
  df <- data.table::fread(segment_file)

  # Rename columns
  names(df)[names(df) == "median"] <- "segVal"
  names(df)[names(df) == "chr"] <- "chromosome"

  # Select relevant columns
  df <- df[, c("chromosome", "start", "end", "segVal", "cell_id")]

  # Split data by cell_id
  df_list <- split(df, df$cell_id)

  # Convert segments to copy number
  long_segs <- SegmentsToCopyNumber(df_list,
                                    bin_size,
                                    genome = genome,
                                    Xincluded = Xincluded)

  long_segs <- long_segs[, c("chromosome", "start", "end", "segmented", "sample_id")]

  # Set column names
  colnames(long_segs) <- c("chromosome", "start", "end", "state", "sample_id")

  # Prepare data for QDNAseq
  df <- long_segs %>%
    tidyr::pivot_wider(names_from = sample_id, values_from = state, names_prefix = "copy_")

  # Create bins
  bins <- Biobase::AnnotatedDataFrame(data.frame(
    chromosome = df$chromosome,
    start = df$start,
    end = df$end,
    row.names = paste(df$chromosome, df$start, df$end, sep = ':')
  ))

  # Extract copy number and segmented data
  copynumber_cols <- grep("^copy_", colnames(df))
  rcn_matrix <- as.data.frame(df[, copynumber_cols, drop = FALSE])
  rownames(rcn_matrix) <- rownames(bins)
  colnames(rcn_matrix) <- stringr::str_replace(colnames(df)[copynumber_cols], "copy_", "")
  rcn_matrix <- rcn_matrix %>%
    dplyr::mutate(dplyr::across(dplyr::everything(), ~ as.numeric(.x)))

  segs_cols <- grep("^copy_", colnames(df))
  segs_matrix <- as.data.frame(df[, segs_cols, drop = FALSE])
  rownames(segs_matrix) <- rownames(bins)
  colnames(segs_matrix) <- stringr::str_replace(colnames(df)[segs_cols], "copy_", "")
  segs_matrix <- segs_matrix %>%
    dplyr::mutate(dplyr::across(dplyr::everything(), ~ as.numeric(.x)))

  # Create QDNAseqCopyNumbers object
  copyNumbers <- new('QDNAseqCopyNumbers',
                     bins = bins,
                     copynumber = as.matrix(rcn_matrix),
                     phenodata = Biobase::AnnotatedDataFrame(data.frame(
                       sampleNames = colnames(rcn_matrix),
                       row.names = colnames(rcn_matrix)
                     ))
  )

  # Assign segmented data
  Biobase::assayDataElement(copyNumbers, "segmented") <- as.matrix(segs_matrix)

  # Prepare to read metadata
  file_pattern <- file.path(input_path, "annotation", "*_metrics.csv.gz")

  # List files matching the pattern
  meta <- list.files(path = dirname(file_pattern),
                     pattern = basename(file_pattern),
                     full.names = TRUE)

  # Filter for files that strictly end with "_metrics.csv.gz"
  meta <- meta[grepl("metrics\\.csv\\.gz$", meta)]

  # Check how many files were found
  if (length(meta) == 0) {
    stop("No metrics files found matching the pattern.")
  } else if (length(meta) > 1) {
    stop("Expected exactly one metrics file, but found: ", length(meta))
  }

  meta <- meta[1]

  # Read the file
  meta_df <- data.table::fread(meta)

  if ("cell_id" %in% colnames(meta_df)) {
    # Merge quality data into the phenoData of copyNumbers
    pheno_data <- copyNumbers@phenoData@data
    pheno_data <- dplyr::left_join(pheno_data,
                                   meta_df, by = c("sampleNames" = "cell_id"))

    # Update the phenoData with quality information
    copyNumbers@phenoData <- Biobase::AnnotatedDataFrame(pheno_data)
  } else {
    stop("Cell ID column not found in metrics")
  }

  return(copyNumbers)
}
