<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Run shallowHRD on a dataframe or file containing segmented relative copy-number data. — RunShallowHRD • utanos</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Run shallowHRD on a dataframe or file containing segmented relative copy-number data. — RunShallowHRD"><meta name="description" content="Utanos' version of the shallowHRD algorithm for detecting homologous recombination deficiency (HRD) on tumor samples from the number of
large genomic alterations (LGAs). Original code found here (https://github.com/aeeckhou/shallowHRD), and original paper found here (https://academic.oup.com/bioinformatics/article/36/12/3888/5823300).
Essentially, the algorithm can be divided into 5 sequential steps. We perform these steps two times (I call them 'passes'),
so the first pass is sort of a 'discovery' stage, with still good estimates, but the second pass improves on the results
from the first pass.
The overall idea is not so complicated: we have some raw segment data and want to find the number of LGAs of size &amp;gt;= 10Mb.
To do so, the 5 steps are (excluding the cleaning functions):
Gather/merge segments by ratio_median: segments that have the same ratio_median might as well be considered as the same
segment: imagine plotting the segments –segment 1– –segment 2–, since they have the same ratio_median, then they're
on the same 'level' in the y-axis, so they can also be: —- a single segment—-. We merge segments in the same ratio_median AND in the same
chromosome arm.
This is what GatherSegmentsByRatioMedian does. The other functions in the section do other minor things: adding chromosome arm column,
removing spurious/unstable regions from the chromosomes, and other cleaning stuff. More description on their activities can be found in
their respective documentation.
NOTE: in CleanBamRatiosFrame you have the option to log-transform the ratio_median's. If some ratio_medians in your file are negative,
then this will produce NANs, in which case there's no need to log-transform.
Finding the threshold: we use KDE to find the minima of the density of all the ratio_median differences (between all pairs of segments).
The idea here is that by finding the local minima of these differences, then we are finding a 'tolerance' point that determines whether
we merge two segments or not. For example, imagine a plot again, and we have two segments (different ratio_medians, so they're not on the same level
in the y-axis) :
—- segment 1 —-   |                             diff &amp;lt;= threshold
|                           ——————&amp;gt;          —- segment 1 + segment 2 —-
|  —- segment 2 —-
Then the threshold indicates whether their distance is meaningful enough such that we should consider them a single segment. So, if their ratio_median
difference is &amp;lt;= threshold, then we consider them the same segment because we aren't completely sure that they are far apart enough. If their ratio_median
difference is &amp;gt; threshold, then we don't merge and we treat each segment as separate segments. All of this is illustrated above. More details on the procedure
of finding the threshold find in the FindThreshold + helpers documentation.
Levels: while we are still not entirely sure the reasoning behind the section, we think that this section assigns segments a sort of 'confidence' in our merging.
The idea here is that the largest segment likely has the highest confidence in its ratio_median as it was easier to sequence. Then, we use it as our reference
to determine how confident we are with the rest of the segments. We use the threshold to see how close the other segments are to this largest segment, and if they are
close (i.e. ratio_median difference &amp;lt;= threshold), then we assign it the same level as the largest segment.
AssignLevels takes care of this. Finally, GatherSegmentsByLevels then merges segments in the same chromosome arm and with the same level.
Small segments. For the previous section, we were only working with 'large' segments, meaning their size is &amp;gt;= 3Mb. Now we have to figure out where the small
segments fit in into our current segment data. InsertSmallSegments takes care of this, and it essentially iterates over the small segments and the large segments,
and checks if we encounter any of the 6 cases it looks for. The cases depend on the positioning of the small segment with respect to the large segment, and they are all
listed/visualized in the helper FinalizeSmallSegments documentation. Wherever appropriate, we merge small and large segments too (i.e. if their ratio_median diff &amp;lt;= threshold).
By the end of the section, we have re-inserted small segments into our main segment data frame.
LGAs: now that we have re-inserted the small segments, we can finally determine the number of LGAs. CallLGA does this, and it is basically iterating over the
finalized segments (marked as Graph 5) and checking which of the segments meet the criteria for an LGA (these requirements are listed in the aforementioned function's documentation.)
The function returns the number of LGAs for different LGA sizes, the paper mostly cares about LGAs of size 10Mb, but you'll get results for sizes 3 to 11.
You can also call GetLGAOfSize, which returns the segments that were marked as an LGA for the given LGA size, in case you want to visualize them.
To determine HRD, check the number of LGAs for 10Mb, and if the number of LGAs &amp;gt;= 20, then HRD was detected.


We repeat this procedure from the second step for the second pass. Note how the FindThreshold function doesn't receive the bam_ratio segments this time. Instead, we pass the
finalized segments found in the first pass (Graph 5) - this is what we meant by 'improving' our results, as we are going to try to find a better threshold for this second
round of function calling.
To finalize, while some of these choices seem arbitrary (e.g. why 3Mb as 'large' segments, and not 5MB? Why is &amp;gt;= 20 LGAs equal to HRD?), perhaps the following paper by the same author can give
some intuition on their choices. Please refer to https://pubmed.ncbi.nlm.nih.gov/22933060/.
Calculates the number of large genomic alterations for various sizes."><meta property="og:description" content="Utanos' version of the shallowHRD algorithm for detecting homologous recombination deficiency (HRD) on tumor samples from the number of
large genomic alterations (LGAs). Original code found here (https://github.com/aeeckhou/shallowHRD), and original paper found here (https://academic.oup.com/bioinformatics/article/36/12/3888/5823300).
Essentially, the algorithm can be divided into 5 sequential steps. We perform these steps two times (I call them 'passes'),
so the first pass is sort of a 'discovery' stage, with still good estimates, but the second pass improves on the results
from the first pass.
The overall idea is not so complicated: we have some raw segment data and want to find the number of LGAs of size &amp;gt;= 10Mb.
To do so, the 5 steps are (excluding the cleaning functions):
Gather/merge segments by ratio_median: segments that have the same ratio_median might as well be considered as the same
segment: imagine plotting the segments –segment 1– –segment 2–, since they have the same ratio_median, then they're
on the same 'level' in the y-axis, so they can also be: —- a single segment—-. We merge segments in the same ratio_median AND in the same
chromosome arm.
This is what GatherSegmentsByRatioMedian does. The other functions in the section do other minor things: adding chromosome arm column,
removing spurious/unstable regions from the chromosomes, and other cleaning stuff. More description on their activities can be found in
their respective documentation.
NOTE: in CleanBamRatiosFrame you have the option to log-transform the ratio_median's. If some ratio_medians in your file are negative,
then this will produce NANs, in which case there's no need to log-transform.
Finding the threshold: we use KDE to find the minima of the density of all the ratio_median differences (between all pairs of segments).
The idea here is that by finding the local minima of these differences, then we are finding a 'tolerance' point that determines whether
we merge two segments or not. For example, imagine a plot again, and we have two segments (different ratio_medians, so they're not on the same level
in the y-axis) :
—- segment 1 —-   |                             diff &amp;lt;= threshold
|                           ——————&amp;gt;          —- segment 1 + segment 2 —-
|  —- segment 2 —-
Then the threshold indicates whether their distance is meaningful enough such that we should consider them a single segment. So, if their ratio_median
difference is &amp;lt;= threshold, then we consider them the same segment because we aren't completely sure that they are far apart enough. If their ratio_median
difference is &amp;gt; threshold, then we don't merge and we treat each segment as separate segments. All of this is illustrated above. More details on the procedure
of finding the threshold find in the FindThreshold + helpers documentation.
Levels: while we are still not entirely sure the reasoning behind the section, we think that this section assigns segments a sort of 'confidence' in our merging.
The idea here is that the largest segment likely has the highest confidence in its ratio_median as it was easier to sequence. Then, we use it as our reference
to determine how confident we are with the rest of the segments. We use the threshold to see how close the other segments are to this largest segment, and if they are
close (i.e. ratio_median difference &amp;lt;= threshold), then we assign it the same level as the largest segment.
AssignLevels takes care of this. Finally, GatherSegmentsByLevels then merges segments in the same chromosome arm and with the same level.
Small segments. For the previous section, we were only working with 'large' segments, meaning their size is &amp;gt;= 3Mb. Now we have to figure out where the small
segments fit in into our current segment data. InsertSmallSegments takes care of this, and it essentially iterates over the small segments and the large segments,
and checks if we encounter any of the 6 cases it looks for. The cases depend on the positioning of the small segment with respect to the large segment, and they are all
listed/visualized in the helper FinalizeSmallSegments documentation. Wherever appropriate, we merge small and large segments too (i.e. if their ratio_median diff &amp;lt;= threshold).
By the end of the section, we have re-inserted small segments into our main segment data frame.
LGAs: now that we have re-inserted the small segments, we can finally determine the number of LGAs. CallLGA does this, and it is basically iterating over the
finalized segments (marked as Graph 5) and checking which of the segments meet the criteria for an LGA (these requirements are listed in the aforementioned function's documentation.)
The function returns the number of LGAs for different LGA sizes, the paper mostly cares about LGAs of size 10Mb, but you'll get results for sizes 3 to 11.
You can also call GetLGAOfSize, which returns the segments that were marked as an LGA for the given LGA size, in case you want to visualize them.
To determine HRD, check the number of LGAs for 10Mb, and if the number of LGAs &amp;gt;= 20, then HRD was detected.


We repeat this procedure from the second step for the second pass. Note how the FindThreshold function doesn't receive the bam_ratio segments this time. Instead, we pass the
finalized segments found in the first pass (Graph 5) - this is what we meant by 'improving' our results, as we are going to try to find a better threshold for this second
round of function calling.
To finalize, while some of these choices seem arbitrary (e.g. why 3Mb as 'large' segments, and not 5MB? Why is &amp;gt;= 20 LGAs equal to HRD?), perhaps the following paper by the same author can give
some intuition on their choices. Please refer to https://pubmed.ncbi.nlm.nih.gov/22933060/.
Calculates the number of large genomic alterations for various sizes."><meta property="og:image" content="https://huntsmanlab.github.io/utanos/logo.png"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">utanos</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/utanos.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/0_quickstart-vignette.html">0. utanos quickstart guide</a></li>
    <li><a class="dropdown-item" href="../articles/1_samplequality-vignette.html">1. Sample Filtering and Quality Evaluation</a></li>
    <li><a class="dropdown-item" href="../articles/2_cndiversityandscaling-vignette.html">2. Investigating Copy-Number Diversity</a></li>
    <li><a class="dropdown-item" href="../articles/3_cnsignatures-vignette.html">3. Investigating and Creating Copy-Number Signatures</a></li>
    <li><a class="dropdown-item" href="../articles/4_shallowhrd-vignette.html">4. Predicting Homologous Recombination Deficiency (HRD)</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Run shallowHRD on a dataframe or file containing segmented relative copy-number data.</h1>

      <div class="d-none name"><code>RunShallowHRD.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Utanos' version of the shallowHRD algorithm for detecting homologous recombination deficiency (HRD) on tumor samples from the number of
large genomic alterations (LGAs). Original code found here (https://github.com/aeeckhou/shallowHRD), and original paper found here (https://academic.oup.com/bioinformatics/article/36/12/3888/5823300).
Essentially, the algorithm can be divided into 5 sequential steps. We perform these steps two times (I call them 'passes'),
so the first pass is sort of a 'discovery' stage, with still good estimates, but the second pass improves on the results
from the first pass.</p>
<p>The overall idea is not so complicated: we have some raw segment data and want to find the number of LGAs of size &gt;= 10Mb.
To do so, the 5 steps are (excluding the cleaning functions):</p><ol><li><p>Gather/merge segments by ratio_median: segments that have the same ratio_median might as well be considered as the same
segment: imagine plotting the segments –segment 1– –segment 2–, since they have the same ratio_median, then they're
on the same 'level' in the y-axis, so they can also be: —- a single segment—-. We merge segments in the same ratio_median AND in the same
chromosome arm.</p>
<p>This is what <code>GatherSegmentsByRatioMedian</code> does. The other functions in the section do other minor things: adding chromosome arm column,
removing spurious/unstable regions from the chromosomes, and other cleaning stuff. More description on their activities can be found in
their respective documentation.</p>
<p>NOTE: in <code>CleanBamRatiosFrame</code> you have the option to log-transform the ratio_median's. If some ratio_medians in your file are negative,
then this will produce NANs, in which case there's no need to log-transform.</p></li>
<li><p>Finding the threshold: we use KDE to find the minima of the density of all the ratio_median differences (between all pairs of segments).
The idea here is that by finding the local minima of these differences, then we are finding a 'tolerance' point that determines whether
we merge two segments or not. For example, imagine a plot again, and we have two segments (different ratio_medians, so they're not on the same level
in the y-axis) :</p>
<p>—- segment 1 —-   |                             diff &lt;= threshold
|                           ——————&gt;          —- segment 1 + segment 2 —-
|  —- segment 2 —-</p>
<p>Then the threshold indicates whether their distance is meaningful enough such that we should consider them a single segment. So, if their ratio_median
difference is &lt;= threshold, then we consider them the same segment because we aren't completely sure that they are far apart enough. If their ratio_median
difference is &gt; threshold, then we don't merge and we treat each segment as separate segments. All of this is illustrated above. More details on the procedure
of finding the threshold find in the <code>FindThreshold</code> + helpers documentation.</p></li>
<li><p>Levels: while we are still not entirely sure the reasoning behind the section, we think that this section assigns segments a sort of 'confidence' in our merging.
The idea here is that the largest segment likely has the highest confidence in its ratio_median as it was easier to sequence. Then, we use it as our reference
to determine how confident we are with the rest of the segments. We use the threshold to see how close the other segments are to this largest segment, and if they are
close (i.e. ratio_median difference &lt;= threshold), then we assign it the same level as the largest segment.
<code>AssignLevels</code> takes care of this. Finally, <code>GatherSegmentsByLevels</code> then merges segments in the same chromosome arm and with the same level.</p></li>
<li><p>Small segments. For the previous section, we were only working with 'large' segments, meaning their size is &gt;= 3Mb. Now we have to figure out where the small
segments fit in into our current segment data. <code>InsertSmallSegments</code> takes care of this, and it essentially iterates over the small segments and the large segments,
and checks if we encounter any of the 6 cases it looks for. The cases depend on the positioning of the small segment with respect to the large segment, and they are all
listed/visualized in the helper <code>FinalizeSmallSegments</code> documentation. Wherever appropriate, we merge small and large segments too (i.e. if their ratio_median diff &lt;= threshold).
By the end of the section, we have re-inserted small segments into our main segment data frame.</p></li>
<li><p>LGAs: now that we have re-inserted the small segments, we can finally determine the number of LGAs. <code>CallLGA</code> does this, and it is basically iterating over the
finalized segments (marked as Graph 5) and checking which of the segments meet the criteria for an LGA (these requirements are listed in the aforementioned function's documentation.)
The function returns the number of LGAs for different LGA sizes, the paper mostly cares about LGAs of size 10Mb, but you'll get results for sizes 3 to 11.
You can also call <code>GetLGAOfSize</code>, which returns the segments that were marked as an LGA for the given LGA size, in case you want to visualize them.</p>
<p>To determine HRD, check the number of LGAs for 10Mb, and if the number of LGAs &gt;= 20, then HRD was detected.</p></li>
</ol><p>We repeat this procedure from the second step for the second pass. Note how the <code>FindThreshold</code> function doesn't receive the bam_ratio segments this time. Instead, we pass the
finalized segments found in the first pass (Graph 5) - this is what we meant by 'improving' our results, as we are going to try to find a better threshold for this second
round of function calling.</p>
<p>To finalize, while some of these choices seem arbitrary (e.g. why 3Mb as 'large' segments, and not 5MB? Why is &gt;= 20 LGAs equal to HRD?), perhaps the following paper by the same author can give
some intuition on their choices. Please refer to https://pubmed.ncbi.nlm.nih.gov/22933060/.
Calculates the number of large genomic alterations for various sizes.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">RunShallowHRD</span><span class="op">(</span></span>
<span>  <span class="va">raw_ratios_file</span>,</span>
<span>  log_transform <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  include_chr_X <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  num_simulations <span class="op">=</span> <span class="fl">1e+05</span>,</span>
<span>  shrd_save_path <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  sample <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  seed <span class="op">=</span> <span class="fl">1337</span>,</span>
<span>  plot <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>


  </main></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Maxwell Douglas, Branden Lynch, Carlos Vasquez, Jacky Yiu, Ding Ma, Nirupama Tamvada, Sameer Shankar.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer></div>





  </body></html>

